#include <stdio.h>

void keisann(int x, int y, int *a1, int *a2);
/*
ポインタは本体とつなぐショートカットであり別に特別なものではない。
本当に本体とショートカットはつながっているのか↓。
  int apple = 10;
  int *hoge;
  hoge = apple;
  printf("%d\n", apple);同じ数値が返ってきたはずです。
  printf("%d\n", *hoge);同じ数値が返ってきたはずです。
  return 0;
”同じ数値が返ってきたはずです。”この数値というのは拡張子や住所と同じような役割をしています。

ポインタ型はポインタ変数のデータ型（int doubleなど）でポインタ型は実体のある変数と一緒にでしか存在することできない。変数によってサイズが異なるため　連携先のデータ型と同じサイズのメモリーをポインタ側も確保する必要がある。
ポインタ値は参照先のアドレスと一緒である上記の例で行けばhoge = apple;は同じ住所（メモリー値）に代入することになるということです。
ポインタ変数はポインタ型宣言された実際の変数で具体的な数値の中身である。特徴は別の変数のアドレスを代入できるのとアドレスデータを読み書きできることです。
特徴は別の変数のアドレスを代入できる：int apple = 10のアドレスを指し示すことでほかの場所でもしようができるようになる。
アドレスデータを読み書きできる：種類が二つあり、ポインタ変数モード（参照元と同じ値（アドレスを記憶することしかできない。））と通常変数モード（参照の値を操作できる（いろいろな演算子を使って計算したり、参照元の値を書き換えることもできる））

ポインタ型の宣言方法↓
int *p;こちらのほうがわかりやすい。
int* p;こちらの場合int* p,p;となった場合に最初に宣言した”p”のみがポインタ型になる。
どちらでもPというポインタを宣言できる。
＆（演算子）がついた変数のアドレスを求める。例↓。
int *p,i;
p = &i;
＆からｐへ代入するコードです。
*/
int main (void) {
  int *apple, iphone;
  apple = &iphone;
  printf("%p\n", apple);
  printf("%p\n", &iphone);

  int *c, o;
  c = &o;
  /*ポインタ変数にこめをつけると通常変数モードに切り替えられる*/
  *c = 15;
  printf("%d\n", *c);
  printf("%d\n", o);

  int tasizann;
  int hikizann;
  keisann(30, 10, &tasizann, &hikizann);
  printf("%d\n", &tasizann);
  printf("%d\n", &hikizann);

  return 0;
}

void keisann(int x, int y, int *a1, int *a2){
    *a1 = x + y;
    *a2 = x - y;
}